"""
Color of NFT from least rare to rarest
"""
enum Color {
  WHITE #tier/class - 1
  YELLOW #tier/class - 2
  BLUE #tier/class - 3
  RED #tier/class - 4
  BLACK #tier/class - 4
}

"""
Class of NFT from least rare to rarest that corresponds to Color. Would use integers, but enums only allow strings.
"""
enum MergeClass {
  ONE
  TWO
  THREE
  FOUR
}

"""
An account of users holding an NFT within merge. collection.
"""
type User @entity {
  "The holder's address of NFT in collection"
  id: ID!
  "Details about NFTs being held by this User"
  massNFTs: [NFT!] @derivedFrom(field: "owner") #pak: allows one to query info about NFTs belonging to this user
  "Whether this User can carry more than one mass NFT"
  whitelist: Boolean #pak: These are central marketplaces typically like Nifty Gateway
}

"""
Individual NFTs within this collection.
"""
type NFT @entity {
  "Unique tokenID"
  id: ID!
  "Whether the NFT has been merged, and therefore deleted"
  merged: Boolean #pak
  "Current owner unless merged where it would be address(0)"
  owner: User!
  "Core metric: used for each NFT in smart contracts to get derived metrics"
  massValue: BigInt!
  "Derived metric: size of mass for a specific NFT"
  massSize: BigInt! #pak
  "Derived metric: color of mass NFT; BLACK is Alpha"
  color: Color! #pak: class in smart contract specifies color where decodeClass(_values[tokenId]) is used in generating metadata (on-chain svg).
  "Derived metric: rarity for mass NFTs; higher numbers are highest rarity"
  mergeClass: MergeClass! #pak: in smart contracts, class is a uint
  "Amount of times this tokenID has absorbed other NFTs"
  mergeCount: Int! #pak
  "Whether the NFT is alpha or not"
  isAlpha: Boolean #pak
  "What tokenId this NFT was merged into"
  mergedInto: String #pak
  "unix timestamps when merge txs occurred"
  timeStamp: [BigInt!]! #pak
  "Absorbed NFTs"
  absorbedNFTs: [String!]! #pak
}
